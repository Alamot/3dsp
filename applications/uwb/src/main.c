/*
 * Initial main.c file generated by Glade. Edit as required.
 * Glade will not overwrite this file.
 */

#ifdef HAVE_CONFIG_H
#  include <config.h>
#endif

#include <unistd.h>
//#include <gnome.h>
#include <gtk/gtk.h>
#include <string.h>
#include <fcntl.h>
#include <errno.h>
#include <sys/ioctl.h>
#include <sys/wait.h>
#include <math.h>
#include <ctype.h>
#include <stdlib.h>
#include "interface.h"
#include "support.h"
#include "main.h"
#include "callbacks.h"

const gchar *tdsp_text;
DEVICE_PNP_STATE g_dsppnpstate;
gboolean g_iscardin;
gboolean g_isclickinginprogress = FALSE;
gboolean g_ismenuclicked = FALSE;
gchar g_chversionstring[256] = { "" };
gint g_allowedmodes[3];
gint g_buspowerstate;
gint g_defaultmode;
gint g_iconindex = 0;
gint g_state = 10;              /*undefined */
GtkWidget *tdsp_text_view;
gulong g_busresetflag;
gulong g_currentserialno;
gulong g_rawenummode = 0;
gulong g_subsystemid;
TDSP_WB_POPMENU tdspuwbmenu;

extern GtkStatusIcon *statusicon;

gint maincontrol()
{
  gint fd;
  gint count;
  count = 0;
  gchar *wbconfig = UWBCONFFILE;

  struct flock lock;

  fd = open(wbconfig, O_RDWR);
  if (fd < 0)
  {
    perror("cannot open the file");
    return 1;
  }

  lock.l_type = F_WRLCK;
  lock.l_whence = 0;
  lock.l_start = 0;
  lock.l_len = 0;

  if (fcntl(fd, F_SETLK, &lock) < 0)
  {
    switch (errno)
    {
    case EAGAIN:
    case EACCES:
      fcntl(fd, F_GETLK, &lock);
      printf("NO! pid:%ld find pid:%ld lock the file %s\n", (long) getpid(), (long) lock.l_pid, wbconfig);
      return 1;
    }
    perror("function fcntl call fail");
    return 1;
  }
  printf("pid: %ld process lock the file successfully!\n", (long) getpid());
  return 0;
}

gint callpipe(gchar * command)
{
  FILE *fp;
  gint count = 0;
  gchar buf[256];

  THISFUNCBECALLED;
  debug("the process to query is: \"%s\"\n", command);
  memset(buf, '\0', 256);
  strcpy(buf, "ps aux|awk '{print $2,$11}'|grep '[/ ]");
  strcat(buf, command);
  strcat(buf, "[ \t]*$'");

  if ((fp = popen(buf, "r")) == NULL)
  {
    perror("popen");
    return 1;
  }
  memset(buf, '\0', sizeof(buf));
  while (fgets(buf, 256, fp) != NULL)
  {
    count++;
    memset(buf, '\0', sizeof(buf));
  }
  pclose(fp);
  return count;
}

gint query_self_process_num(gchar * argv)
{
  gint count = 0;
  gchar *pcommand, command[64];
  memset(command, '\0', 64);
  pcommand = strrchr(argv, '/');
  if (pcommand == 0)
    strcpy(command, argv);
  else
    snprintf(command, 63, "%s", pcommand + 1);
  count = callpipe(command);
  return count;
}

/**to call for another program MA**/
void me_startup_another(gchar * filename)
{
  pid_t pid;

  THISFUNCBECALLED;
  pid = fork();
  debug("fork get pid is: %ld \n", (long) pid);
  if (pid < 0)
  {
    debug("pid < 0\n");
    perror("fork");
    return;
  }
  if (pid > 0)
  {
    sleep(1);
  }
  if (pid == 0)
  {
    execlp(filename, filename, NULL);
    perror(filename);
    exit(1);
  }
  return;
}

void call_shell_for_btEnv(char *shellfile)
{
  pid_t pid;
  THISFUNCBECALLED;
  printf("\n");
  pid = fork();
  if (pid == 0)
  {
    execlp("bash", "bash", shellfile, (char *) 0);
  }
  if (pid != 0)
  {
    int stat_val;
    wait(&stat_val);
    if (WIFEXITED(stat_val))
      debug("Child exited normally\n");
    else
      printf("Child terminated abnormally\n");
  }
  sleep(1);
  return;
}

/***send a signal to close tdspusbma by write a pipe-file: /tmp/TdspUsbMAFIFO ***/
void send_signal_close_tdspusbma()
{
  gint fp;

  if ((fp = open(FIFO_FILE, O_WRONLY | O_NONBLOCK)) == 0)
  {
    perror("open");
    return;
  }
  write(fp, "quitma", 6);
  close(fp);
  return;
}

int open_device(char *devicename)
{
  int fd;
  fd = open(devicename, O_RDONLY);
// debug ("open_device success, and its handle: fd = 0x%x\n",fd); 
  if (fd == -1)
  {
    debug("ERROR: %s:open file fail \n",__func__); 
    g_iscardin = FALSE;
  }
  return (fd);
}

void close_device(int fd)
{
  // debug ("close_device: fd = 0x%x\n",fd);  
  close(fd);
}

int ioctl_device(int fd, int cmd, void *data)
{
  debug("ioctl_device: fd = 0x%x, cmd = 0x%x\n", fd, cmd);
  return (ioctl(fd, cmd, data));
}

int tdsp_query_subsystem_id()
{
  int fd;
  gulong ret;
  debug("call the function: tdsp_query_subsystem_id \n");
  ret = 0;
  fd = open_device(TDSP_BUS_DEVICE_NAME);
  if (fd == -1)
  {
    perror("open error");
    return TDSP_SERIAL_NO_NOCARD;
  }
  if (ioctl_device(fd, TDSP_GET_SUB_SYSTEM_ID_INFO, &ret) != 0)
  {
    close_device(fd);
    perror("ioctl error");
    return TDSP_SERIAL_NO_NOCARD;
  }
  debug("Query Bus subsystem id: ret = 0x%lx\n", ret);
  close_device(fd);
  g_subsystemid = ret;
  return ret;
}

int tdsp_query_power_state()
{
  int fd;
  int ret;
  debug("call the function: tdsp_query_power_state()\n");
  g_buspowerstate = PowerOff;
  fd = open_device(TDSP_BUS_DEVICE_NAME);
  if (fd == -1)
  {
    debug(": open file error, fail!\n");
    perror("open error");
    return TDSP_SERIAL_NO_NOCARD;
  }
  if (ioctl_device(fd, TDSP_QUERY_BUS_POWER_STATE, &ret) != 0)
  {
    close_device(fd);
    debug(": ioctl error, fail!\n");
    perror("ioctl error");
    return TDSP_SERIAL_NO_NOCARD;
  }
  close_device(fd);
  debug("tdsp_query_power_state: ret = 0x%x\n", ret);
  g_buspowerstate = ret;
  return ret;
}

int tdsp_query_device()
{
  int fd;
  int ret;
  debug("call the function: tdsp_query_device \n");
  g_iscardin = FALSE;
  g_currentserialno = TDSP_SERIAL_NO_NOCARD;

  fd = open_device(TDSP_BUS_DEVICE_NAME);
  if (fd == -1)
  {
    perror("open error");
    return TDSP_SERIAL_NO_NOCARD;
  }
  if (ioctl_device(fd, TDSP_DISPLAY_IN_USE, &ret) == -1)
  {
    close_device(fd);
    perror("ioctl error");
    return TDSP_SERIAL_NO_NOCARD;
  }
  // debug ("tdsp_query_device: ret = 0x%x\n",ret); 
  close_device(fd);
  g_currentserialno = ret;
  g_iscardin = TRUE;
  debug(">tdsp_query_device: g_iscardin = %d and g_currentserialno = 0x%lx\n", g_iscardin, g_currentserialno);

  return ret;
}

gint tdsp_query_reset_flag()
{
  int fd;
  int ret;
  g_busresetflag = 0;
  debug("call the function: tdsp_query_reset_flag()\n");
  fd = open_device(TDSP_BUS_DEVICE_NAME);
  if (fd == -1)
  {
    perror("open error");
    return -1;
  }
  if (ioctl_device(fd, TDSP_QUERY_RESET_FLAG, &ret) == -1)
  {
    close_device(fd);
    perror("ioctl error");
    return -1;
  }
  close_device(fd);
  debug(">query_reset_flag: ret =  %d (0 is right, 1 is no right)\n", ret);
  g_busresetflag = ret;
  return ret;
}

gint tdsp_query_pnp_state(gulong mode)
{
  debug("call the function: tdsp_query_pnp_state(%ld) \n", mode);
  int fd;
  int ret = mode;
  g_dsppnpstate = UnKnown;
  fd = open_device(TDSP_BUS_DEVICE_NAME);
  if (fd == -1)
  {
    perror("openerror");
    return 4;
  }
  if (ioctl_device(fd, TDSP_QUERY_DEVICE_STATE, &ret) == -1)
  {
    close_device(fd);
    perror("ioctlerror");
    return 4;
  }
  close_device(fd);

  g_dsppnpstate = (DEVICE_PNP_STATE) ret;
  debug(">query_pnp_state success: g_dsppnpstate = 0x%x\n", ret);
  return ret;
}

gboolean tdsp_download_dsp_code(unsigned long serialno)
{
  int fd;
  debug("call the function: tdsp_download_dsp_code(%ld)\n", serialno);
  fd = open_device(TDSP_BUS_DEVICE_NAME);
  if (fd == -1)
  {
    perror("open error");
    return FALSE;
  }
  gulong dwioctlcode;
  if (serialno == TDSP_SERIAL_NO_BT)
  {
    dwioctlcode = TDSP_RELOAD_BT_CODE;
  }
  else if (serialno == TDSP_SERIAL_NO_WLAN)
  {
    dwioctlcode = TDSP_RELOAD_WLAN_CODE;
  }
  else if (serialno == TDSP_SERIAL_NO_COEXIST)
  {
    dwioctlcode = TDSP_RELOAD_COMBO_CODE;
  }
  else
  {
    debug("the serialno is incorrect !");
    close_device(fd);
    return FALSE;
  }

  if (ioctl_device(fd, dwioctlcode, NULL) == -1)
  {
    debug("Download DSP CODE Failed!\n");
    close_device(fd);
    return FALSE;
  }
  usleep(200000);
  debug("Download DSP code success!\n");
  close_device(fd);
  return TRUE;
}

gboolean tdsp_set_init_flag(gulong mode)
{
  int fd;
  int ret = mode;
  debug("call the function: tdsp_set_init_flag( %ld)\n", mode);
  fd = open_device(TDSP_BUS_DEVICE_NAME);
  if (fd == -1)
  {
    perror("openerror");
    return FALSE;
  }
  if (ioctl_device(fd, TDSP_SET_INIT_FLAG, &ret) == -1)
  {
    close_device(fd);
    perror("ioctlerror");
    return FALSE;
  }
  close_device(fd);
  debug(" tdsp_set_init_flag success!\n");
  return TRUE;
}

int set_hotkey_flag(unsigned long nmode)
{
  debug("call the function: set_hotkey_flag(%ld)!\n", nmode);
  int fd;
  unsigned long mode = nmode;
  fd = open_device(TDSP_BUS_DEVICE_NAME);
  if (fd == -1)
  {
    perror("open error");
    return -1;
  }
  if (ioctl_device(fd, TDSP_SET_HOT_FLAG, &mode) == -1)
  {
    close_device(fd);
    perror("set_hotkey_flag: ioctl error");
    return -1;
  }
  debug("set_hotkey_flag: success!\n");
  close_device(fd);
  return 0;
}

int set_antenna_flag(unsigned long nmode)
{
  debug("call the function: set_antenna_flag(%ld)!\n", nmode);
  int fd;
  unsigned long mode = nmode;
  fd = open_device(TDSP_BUS_DEVICE_NAME);
  if (fd == -1)
  {
    perror("open error");
    return -1;
  }
  if (ioctl_device(fd, TDSP_SET_ANTENNA, &mode) == -1)
  {
    close_device(fd);
    perror("set_antenna_flag: ioctl error");
    return -1;
  }
  debug("set_antenna_flag: success!\n");
  close_device(fd);
  return 0;
}

int read_enum_mode()
{
  int fd;
  gulong ret;
  debug("call the function: read_enum_mode() \n");
  fd = open_device(TDSP_BUS_DEVICE_NAME);
  if (fd == -1)
  {
    perror("open error");
    return -1;
  }
  if (ioctl_device(fd, TDSP_READ_ENUM_MODE, &ret) != 0)
  {
    close_device(fd);
    perror("ioctl error");
    return -1;
  }
  debug(">read_enum_mode is: ret = 0x%lx\n", ret);
  close_device(fd);
  g_rawenummode = ret;
  return ret;
}

int write_enum_mode(unsigned long mode)
{
  debug("call the function: tdsp_write_enum_mode(%ld)!\n", mode);
  int fd;
  fd = open_device(TDSP_BUS_DEVICE_NAME);
  if (fd == -1)
  {
    perror("open error");
    return -1;
  }
  if (ioctl_device(fd, TDSP_WRITE_ENUM_MODE, &mode) == -1)
  {
    close_device(fd);
    perror("tdsp_write_enum_mode: ioctl error");
    return -1;
  }
  debug("tdsp_ write_enum_mode: success!\n");
  close_device(fd);
  return 0;
}

/*plugin device, when success return the device's serialno, when failure return TDSP_SERIAL_NOCARD 0X10000*/
int tdsp_add_device(char *devicename, unsigned long namelen, unsigned long serialno)
{
  int fd;
  int bytes;
  PBUSENUM_PLUGIN_HARDWARE hardware;
  debug("call the function: tdsp_add_device(%s, %ld, %ld)!\n", devicename, namelen, serialno);
  fd = open_device(TDSP_BUS_DEVICE_NAME);
  if (fd == -1)
  {
    perror("open error");
    return TDSP_SERIAL_NO_NOCARD;
  }
  bytes = sizeof(BUSENUM_PLUGIN_HARDWARE) + namelen;
  hardware = (PBUSENUM_PLUGIN_HARDWARE) malloc(bytes);
  if (hardware == NULL)
  {
    debug("tdsp_add_device: malloc hardware error\n");
    close_device(fd);
    return TDSP_SERIAL_NO_NOCARD;
  }
  hardware->Size = sizeof(BUSENUM_PLUGIN_HARDWARE);
  hardware->SerialNo = serialno;
  memcpy(hardware->HardwareIDs, devicename, namelen);
  // debug ("tdsp_add_device: namelen = %d, total len = %d, the serialno is:%d\n", namelen, bytes,serialno);  
  if (ioctl_device(fd, TDSP_PLUGIN, hardware) == -1)
  {
    free(hardware);
    close_device(fd);
    perror("tdsp_add_device: ioctl error");
    return TDSP_SERIAL_NO_NOCARD;
  }
  debug(">tdsp_add_device: success!the serialno is %ld\n", serialno);
  free(hardware);
  close_device(fd);
  return serialno;
}

/*remove device, when success, it return the device's serialno, when failure, return TDSP_SERIAL_NOCARD 0X10000*/
int tdsp_remove_device(unsigned long serialno)
{
  int fd;
  BUSENUM_UNPLUG_HARDWARE unplug;
  int bytes;

  debug("call the function: tdsp_remove_device( %ld)\n", serialno);
  fd = open_device(TDSP_BUS_DEVICE_NAME);
  if (fd == -1)
  {
    perror("tdsp_remove_device, open error");
    return TDSP_SERIAL_NO_NOCARD;
  }

  unplug.Size = bytes = sizeof(unplug);
  unplug.SerialNo = serialno;
  if (ioctl_device(fd, TDSP_UNPLUG, &unplug) == -1)
  {
    close_device(fd);
    perror("tdsp_remove_device: ioctl error");
    return TDSP_SERIAL_NO_NOCARD;
  }
  close_device(fd);
  debug(">remove_device( %ld ): success\n", serialno);
  return serialno;
}

gboolean tdsp_is_download_dspcode_ok()
{
  debug("call the fuction: tdsp_is_download_dspcode_ok()\n");
  tdsp_query_device();
  if (g_iscardin == TRUE && g_currentserialno != 0xffff)
  {
    debug("> is_download_dspcode_ok(), g_currentserialno is: 0x%lx, success!\n", g_currentserialno);
    return TRUE;
  }
  else
  {
    debug("> is_download_dspcode_ok(), g_currentserialno is: 0x%lx, fail!\n", g_currentserialno);
    return FALSE;
  }
}

gboolean unplugdevices()
{
  debug("call the function: unplugdevices() \n");
  if (g_state == BLUETOOTH_DISABLE_WLAN_DISABLE)
  {
    return TRUE;
  }
  tdsp_query_device();
  if (g_currentserialno == TDSP_SERIAL_NO_NOCARD)
  {
    return FALSE;
    /*should kill the program! */
  }

  if (g_currentserialno == TDSP_SERIAL_NO_NONE)
  {
    return TRUE;
  }

  int iiTimes = 0;
  do
  {
    if (tdsp_query_reset_flag() == -1)
      debug("have error in fuction: tdsp_query_reset_flag()\n");
    if (g_busresetflag == 1)
    {
      usleep(1000000);
    }
    iiTimes++;
  }
  while (g_busresetflag == 1 && iiTimes < 60);
  debug("--g_busresetflag = %ld,  and the loopcount iiTimes = %d\n", g_busresetflag, iiTimes);

  write_enum_mode(0);

  if (g_state == BLUETOOTH_ENABLE_WLAN_DISABLE)
  {
    tdsp_remove_device(TDSP_SERIAL_NO_BT);
    usleep(500000);
  }

  if (g_state == BLUETOOTH_DISABLE_WLAN_ENABLE)
  {
    tdsp_remove_device(TDSP_SERIAL_NO_WLAN);
    usleep(500000);
  }

  if (g_state == BLUETOOTH_ENABLE_WLAN_ENABLE)
  {
    tdsp_remove_device(TDSP_SERIAL_NO_BT);
    usleep(500000);
    int iTimes = 0;
    do
    {
      tdsp_query_power_state();
      if (g_buspowerstate != PowerOn)
      {
        g_message("return becaus g_buspowerstate != PowerOn\n");
        return FALSE;
      }
      tdsp_query_device();
      usleep(500000);
      if (g_currentserialno == 0xffff)
        break;
      iTimes++;
    }
    while ((g_currentserialno & 0x1) == 0x1 && iTimes < 600);

    tdsp_remove_device(TDSP_SERIAL_NO_WLAN);
    usleep(500000);
  }

  int iTimes = 0;
  do
  {
    tdsp_query_power_state();
    if (g_buspowerstate != PowerOn)
    {
      g_message("return becaus g_buspowerstate != PowerOn\n");
      return FALSE;
    }

    tdsp_query_device();
    usleep(500000);
    iTimes++;
  }
  while (g_currentserialno != 0xffff && iTimes < 1200);
  debug(">unplugdevice, the variable: g_currentserialno is 0x%lx\n", g_currentserialno);

  g_state = BLUETOOTH_DISABLE_WLAN_DISABLE;
  return TRUE;
}

void wait_device_unplug_stable()
{
#define TIMEOUTS 5
  debug("call the function: wait_device_unplug_stable()\n");
  tdsp_query_pnp_state(1);
  int nWaitCount = 0;
  while (g_dsppnpstate != 0xFF && nWaitCount < TIMEOUTS)
  {
    usleep(500000);
    tdsp_query_pnp_state(1);
    nWaitCount++;
  }
  tdsp_query_pnp_state(2);
  nWaitCount = 0;
  while (g_dsppnpstate != 0xFF && nWaitCount < TIMEOUTS)
  {
    usleep(500000);
    tdsp_query_pnp_state(2);
    nWaitCount++;
  }
  return;
}

gint initial_wb_defaultmode()
{
  debug("call the function: initial_wb_defaultmode \n");
  int nenummode;
  nenummode = read_enum_mode();
  if (nenummode == -1)
  {
    debug("read_enum_mode fail! ");
    debug("the g_defaultmode is: %d \n", g_defaultmode);
    return -1;
  }
  if (nenummode != 0)
  {
    if (g_allowedmodes[nenummode - 1] != 1)
      nenummode = 0;
  }

  g_rawenummode = nenummode;
/*  if (nenummode == 0)
  {
    nenummode = g_defaultmode;
  }*/
  g_defaultmode = nenummode;
  debug("%s:the g_defaultmode is: %d \n",__func__, g_defaultmode);
  return 0;
}

char *trim_gets_string(char *valstring)
{
  char *p = NULL, *pret = NULL;
  for (p = valstring; p - valstring < strlen(valstring); p++)
  {
    if (*p == 32 || *p == 9)
    {
      pret = p + 1;
      continue;
    }
    break;
  }
  for (p = valstring; p - valstring < strlen(valstring); p++)
  {
    if (*p == 10 || *p == 13)
    {
      *p = 0;
      break;
    }
  }
  return pret;
}

int get_value_from_conffile(FILE * fp, char *keystring, char *valstring)
{
  FILE *ini;
  char *name = NULL, *value = NULL, line[100];
  ini = fp;
  rewind(ini);
  if (ini == NULL)
    ini = fopen(UWBCONFFILE, "r");
  while (!feof(ini))
  {
    fgets(line, 100, ini);
    if (*line == ';')
    {
      memset(line, '0', 100);
      continue;
    }
    trim_gets_string(line);
    name = strtok(line, "=");
    value = strtok(0, "=");
    if (name && value)
    {
      if (strcasecmp(name, keystring) == 0)
      {
        strcpy(valstring, value);
        debug("%s=%s\n", keystring, valstring);
        return 1;
      }
    }
    else
      continue;
    if (strcasecmp(name, "MENU_BT") == 0)
      break;
  }
  printf("\n");
  return 0;
}

gboolean get_config_from_file()
{
  FILE *fp;
  fp = fopen(UWBCONFFILE, "r");
  if (fp == NULL)
  {
    debug("the config file 'wb.conf' is not exist in '%s'!\n", UWBCONFFILE);
    return FALSE;
  }

  char recstring[100], chtmp[10];
  debug("call the function: get_config_from_file\n");

  if (get_value_from_conffile(fp, "HOTKEYFLAG", recstring) != 0)
  {
    m_nHotKeyFlag = atoi(recstring);
  }
  if (m_nHotKeyFlag > 1 || m_nHotKeyFlag < 0)
  {
    m_nHotKeyFlag = 0;
    goto END;
  }
  /*
     if(get_value_from_conffile(fp, "DEVAG", recstring)!=0){
     strcpy(m_chagdesc,recstring);
     }   
     else 
     goto END;

     if(get_value_from_conffile(fp, "DEVGONLY", recstring)!=0){
     strcpy(m_chgonlydesc,recstring);
     }
     else 
     goto END;

     // *[BT] *  BTV1=3DSP BlueToothv.1.0 *BTV2=3DSP BlueToothv.2.0 
     if(get_value_from_conffile(fp, "BTV1", recstring)!=0){
     strcpy(m_chbt1desc,recstring);
     }
     else 
     goto END;

     if(get_value_from_conffile(fp, "BTV2", recstring)!=0){
     strcpy(m_chbt2desc,recstring);
     }
     else 
     goto END;

     // **      [WB]   **    
     if(get_value_from_conffile(fp, "SYSTEMTRAYTIPS", recstring)!=0){
     strcpy(m_chsystemtraytips,recstring);
     }
     else 
     goto END; */

  if (get_value_from_conffile(fp, "COMPANYID", recstring) != 0)
  {
    strcpy(m_chcompanyid, recstring);
  }
  else
    goto END;

/*	 if(get_value_from_conffile(fp, "WLANCFGEXITNORMALLY", recstring)!=0){
     m_nwlancfgexitnormally=atoi(recstring);
     }
     if(!(m_nwlancfgexitnormally==0||m_nwlancfgexitnormally==1)){
     goto END;
     }

     if(get_value_from_conffile(fp, "SHOWWARNING", recstring)!=0){
     m_nshowwarning=atoi(recstring);
     }

     if(get_value_from_conffile(fp, "COEXISTWARNING", recstring)!=0){
     strcpy(m_chcoexistwarning,recstring);
     }
     else 
     goto END;
   */
  if (get_value_from_conffile(fp, "DEFAULTMODE", recstring) != 0)
  {
    g_defaultmode = atoi(recstring);
  }
  if (g_defaultmode > 3 || g_defaultmode <= 0)
  {
    g_defaultmode = 0;
    goto END;
  }

  if (get_value_from_conffile(fp, "ALLOWEDMODES", recstring) != 0)
  {
    strcpy(chtmp, recstring);
  }
  else
    goto END;

  int nlen = strlen(chtmp);
  if (nlen > 3)
  {
    chtmp[3] = '\0';
  }
  debug("--------------------------%d,%d,%d,%d,%d\n", chtmp[0], chtmp[1], chtmp[2], chtmp[3], nlen);
  int i, index;
  for (i = 0; i < nlen; i++)
  {
    index = chtmp[i] - '0' - 1;
    if (index >= 3 || index < 0)
    {
      goto END;
    }
    g_allowedmodes[index] = 1;
  }
  debug("g_allowedmodes[0]=%d,g_allowedmodes[1]=%d,g_allowedmodes[2]=%d,g_defaultmode=%d\n", g_allowedmodes[0], g_allowedmodes[1], g_allowedmodes[2], g_defaultmode);
  if (g_allowedmodes[g_defaultmode - 1] != 1)
    goto END;

  if (get_value_from_conffile(fp, "VERSION", recstring) != 0)
  {
    strcpy(m_chversion, recstring);
  }
  else
    goto END;

  if (get_value_from_conffile(fp, "RELEASEDATE", recstring) != 0)
  {
    strcpy(m_chreleasedate, recstring);
  }
  else
    goto END;

  if (get_value_from_conffile(fp, "PRODUCTID", recstring) != 0)
  {
    strcpy(m_chproductid, recstring);
  }
  else
    goto END;

  if (get_value_from_conffile(fp, "ANTENNAFLAG", recstring) != 0)
  {
    m_nAntennaFlag = atoi(recstring);
  }
  if (m_nAntennaFlag > 2 || m_nAntennaFlag < 1)
  {
    m_nAntennaFlag = 0;
//    goto END;
  }

  debug
    ("\nm_chagdesc:%s,\nm_chgonlydesc:%s,\nm_chbt1desc:%s,\nm_chbt2desc:%s,\nm_chsystemtraytips:%s,\nm_chcompanyid:%s,\nm_nwlancfgexitnormally:%d,\nm_nshowwarning:%d,\nm_chcoexistwarning:%s,\nm_chversion:%s,\nm_chreleasedate:%s,\nm_chproductid:%s\n",
     m_chagdesc, m_chgonlydesc, m_chbt1desc, m_chbt2desc, m_chsystemtraytips, m_chcompanyid, m_nwlancfgexitnormally, m_nshowwarning, m_chcoexistwarning, m_chversion, m_chreleasedate, m_chproductid);

  fclose(fp);
  return TRUE;
END:
  //printf("\nm_chagdesc:%s,\nm_chgonlydesc:%s,\nm_chbt1desc:%s,\nm_chbt2desc:%s,\nm_chsystemtraytips:%s,\nm_chcompanyid:%s,\nm_nwlancfgexitnormally:%d,\nm_nshowwarning:%d,\nm_chcoexistwarning:%s,\nm_chversion:%s,\nm_chreleasedate:%s,\nm_chproductid:%s\n",m_chagdesc,m_chgonlydesc,m_chbt1desc,m_chbt2desc,m_chsystemtraytips,m_chcompanyid,m_nwlancfgexitnormally,m_nshowwarning,m_chcoexistwarning,m_chversion,m_chreleasedate,m_chproductid);
  fclose(fp);
  return FALSE;
}

void gray_wb_menu()
{
  THISFUNCBECALLED;
  gtk_widget_set_sensitive(tdspuwbmenu.bluetooth, FALSE);
  gtk_widget_set_sensitive(tdspuwbmenu.wlan, FALSE);
  gtk_widget_set_sensitive(tdspuwbmenu.coexist, FALSE);
  gtk_widget_set_sensitive(tdspuwbmenu.unplug, FALSE);
  return;
}

void enable_wb_menu()
{
  THISFUNCBECALLED;
  gtk_widget_set_sensitive(tdspuwbmenu.bluetooth, g_allowedmodes[0]);
  gtk_widget_set_sensitive(tdspuwbmenu.wlan, g_allowedmodes[1]);
  gtk_widget_set_sensitive(tdspuwbmenu.coexist, g_allowedmodes[2]);
  gtk_widget_set_sensitive(tdspuwbmenu.unplug, TRUE);

  return;
}

void adjust_menu_item(gint modemenuitem)
{
  THISFUNCBECALLED;

  gtk_check_menu_item_set_active(GTK_CHECK_MENU_ITEM(tdspuwbmenu.bluetooth), FALSE);
  gtk_check_menu_item_set_active(GTK_CHECK_MENU_ITEM(tdspuwbmenu.wlan), FALSE);
  gtk_check_menu_item_set_active(GTK_CHECK_MENU_ITEM(tdspuwbmenu.coexist), FALSE);
  gtk_check_menu_item_set_active(GTK_CHECK_MENU_ITEM(tdspuwbmenu.unplug), FALSE);
  switch (modemenuitem)
  {
  case (MODE_UNPLUG):
    gtk_check_menu_item_set_active(GTK_CHECK_MENU_ITEM(tdspuwbmenu.unplug), TRUE);
    break;
  case (MODE_BLUETOOTH):
    gtk_check_menu_item_set_active(GTK_CHECK_MENU_ITEM(tdspuwbmenu.bluetooth), TRUE);
    break;
  case (MODE_WLAN):
    gtk_check_menu_item_set_active(GTK_CHECK_MENU_ITEM(tdspuwbmenu.wlan), TRUE);
    break;
  case (MODE_COEXIST):
    gtk_check_menu_item_set_active(GTK_CHECK_MENU_ITEM(tdspuwbmenu.coexist), TRUE);
    break;
  default:
    break;
  }
  return;
}

/*** the initial function of wb stats ***/
void tdsp_init_menu()
{
  debug("call the function: tdsp_init_menu()\n");
  tdsp_query_power_state();
  if (g_buspowerstate == PowerOn)
  {
    g_iconindex = ICON_GREEN;
    switch (g_defaultmode)
    {
    case 1:
      g_ismenuclicked = TRUE;
      on_bluetooth_activate((GtkMenuItem *) tdspuwbmenu.bluetooth, NULL);
      break;
    case 2:
      g_ismenuclicked = TRUE;
      on_wlan1_activate(NULL, NULL);
      break;
    case 3:
      g_ismenuclicked = TRUE;
      on_coexist1_activate(NULL, NULL);
      break;
    case 0:
      g_ismenuclicked = TRUE;
      on_unplug1_activate(NULL, NULL);
      break;
    default:
      break;
    }
   debug("%s:the g_defaultmode is: %d \n",__func__, g_defaultmode); 
  }
  else
  {
    g_ismenuclicked = FALSE;
    gray_wb_menu();
    g_iconindex = ICON_GRAY;
    adjust_icon(g_iconindex);
    switch (g_rawenummode)
    {
    case 1:
      adjust_menu_item(MODE_BLUETOOTH);
      break;
    case 2:
      adjust_menu_item(MODE_WLAN);
      break;
    case 3:
      adjust_menu_item(MODE_COEXIST);
      break;
    case 0:
      adjust_menu_item(MODE_UNPLUG);
      break;
    default:
      adjust_menu_item(MODE_NULL);
      break;
    }
  }
  return;
}

void adjust_func_state()
{
  debug("call the function: adjust_func_state()\n ");
  tdsp_query_device();
  if (g_iscardin == FALSE)
  {
    g_state = BLUETOOTH_DISABLE_WLAN_DISABLE;
  }
  if (g_currentserialno == 0x1)
  {
    g_state = BLUETOOTH_ENABLE_WLAN_DISABLE;
  }
  else if (g_currentserialno == 0x2)
  {
    g_state = BLUETOOTH_DISABLE_WLAN_ENABLE;
  }
  else if (g_currentserialno == 0x3)
  {
    g_state = BLUETOOTH_ENABLE_WLAN_ENABLE;
  }
  else if (g_currentserialno == 0xffff)
  {
    g_state = BLUETOOTH_DISABLE_WLAN_DISABLE;
  }
}

void adjust_menu_item_auto()
{
  debug("call the function: adjust_menu_item_auto()\n");
  g_ismenuclicked = FALSE;
  gtk_check_menu_item_set_active(GTK_CHECK_MENU_ITEM(tdspuwbmenu.bluetooth), FALSE);
  gtk_check_menu_item_set_active(GTK_CHECK_MENU_ITEM(tdspuwbmenu.wlan), FALSE);
  gtk_check_menu_item_set_active(GTK_CHECK_MENU_ITEM(tdspuwbmenu.coexist), FALSE);
  gtk_check_menu_item_set_active(GTK_CHECK_MENU_ITEM(tdspuwbmenu.unplug), FALSE);
  adjust_func_state();
  switch (g_state)
  {
  case (BLUETOOTH_DISABLE_WLAN_DISABLE):
    gtk_check_menu_item_set_active(GTK_CHECK_MENU_ITEM(tdspuwbmenu.unplug), TRUE);
    break;
  case (BLUETOOTH_ENABLE_WLAN_DISABLE):
    gtk_check_menu_item_set_active(GTK_CHECK_MENU_ITEM(tdspuwbmenu.bluetooth), TRUE);
    break;
  case (BLUETOOTH_DISABLE_WLAN_ENABLE):
    gtk_check_menu_item_set_active(GTK_CHECK_MENU_ITEM(tdspuwbmenu.wlan), TRUE);
    break;
  case (BLUETOOTH_ENABLE_WLAN_ENABLE):
    gtk_check_menu_item_set_active(GTK_CHECK_MENU_ITEM(tdspuwbmenu.coexist), TRUE);
    break;
  default:
    gtk_check_menu_item_set_active(GTK_CHECK_MENU_ITEM(tdspuwbmenu.unplug), TRUE);
    break;
  }
//  g_ismenuclicked = TRUE;
}

GtkWidget *create_pixmap_fromxpm(GtkWidget * window, char **string)
{
  GtkWidget *pixmapwid;
  GdkPixmap *pixmap;
  GdkBitmap *mask;
  GtkStyle *style;

  debug("call the function: create_pixmap_fromxpm()\n");
  style = gtk_widget_get_style(window);
  pixmap = gdk_pixmap_create_from_xpm_d(window->window, &mask, &style->bg[GTK_STATE_NORMAL], (gchar **) string);
  pixmapwid = gtk_pixmap_new(pixmap, mask);
  return pixmapwid;
}

void refresh_gui_and_timeout()
{
  debug("- -\n");
  while (gtk_events_pending())
    gtk_main_iteration();
  debug("- -\n");
}

void hexstr2intnum(gchar * psrc, gint nlen, gint * num)
{
  int i = 0;
  *num = 0;
  for (i = 0; i < nlen; i++)
  {
    int nval = toupper(psrc[i]);
    if (nval >= 'A')
    {
      nval = nval - 'A' + 10;
    }
    else
    {
      nval = nval - '0';
    }
    *num += (int) (nval * pow(16, nlen - i - 1));
  }
  return;
}

gboolean get_tdsp_version(PTDSPVERSION ver)
{
  int fd;
  unsigned char verinfo[64];
  debug("call the function: get_tdsp_version()\n");
  fd = open_device(TDSP_BUS_DEVICE_NAME);
  if (fd == -1)
  {
    perror("open error");
    return -1;
  }

  gboolean bsuccess;
  bsuccess = FALSE;
  if (ver->pos[0] == 1)
  {
    long serial = 1;
    memset(verinfo, '\0', 64);
    memcpy(verinfo, &serial, sizeof(serial));
    if (ioctl_device(fd, TDSP_QUERY_DEVICE_VERSION, &verinfo) == -1)
    {
      close_device(fd);
      ver->pos[0] = 0;
      perror("ioctl error");
      return -1;
    }
    else
    {
      strcpy((char *) ver->btver, (char *) verinfo);
    }
  }
  if (ver->pos[1] == 1)
  {
    long serial = 2;
    memset(verinfo, '\0', 64);
    memcpy(verinfo, &serial, sizeof(serial));
    if (ioctl_device(fd, TDSP_QUERY_DEVICE_VERSION, &verinfo) == -1)
    {
      close_device(fd);
      ver->pos[1] = 0;
      perror("ioctl error");
      return -1;
    }
    else
    {
      strcpy((char *) ver->wlanver, (char *) verinfo);
    }
  }
  if (ver->pos[2] == 1)
  {
    memset(verinfo, '\0', 64);
    if (ioctl_device(fd, TDSP_QUERY_BUS_VERSION, &verinfo) == -1)
    {
      close_device(fd);
      ver->pos[2] = 0;
      perror("ioctl error");
      return -1;
    }
    else
    {
      strcpy((char *) ver->busver, (char *) verinfo);
    }
  }
  if (ver->pos[3] == 1)
  {
    unsigned long verinfo1;
    if (ioctl_device(fd, TDSP_QUERY_FIRMWARE_VERSION, &verinfo1) == -1)
    {
      close_device(fd);
      ver->pos[3] = 0;
      perror("ioctl error");
      return -1;
    }
    else
    {
      ver->firmwarever = verinfo1;
    }
  }
  close_device(fd);
  return TRUE;
}

void update_ver_string()
{
  TDSPVERSION ver;
  memset(&ver, 0, sizeof(ver));
  ver.pos[0] = ver.pos[1] = 0;
  ver.pos[2] = ver.pos[3] = 1;
  if (g_state == BLUETOOTH_ENABLE_WLAN_ENABLE)
  {
    ver.pos[0] = ver.pos[1] = 1;
  }
  else if (g_state == BLUETOOTH_ENABLE_WLAN_DISABLE)
  {
    ver.pos[0] = 1;
  }
  else if (g_state == BLUETOOTH_DISABLE_WLAN_ENABLE)
  {
    ver.pos[1] = 1;
  }
  if (FALSE == get_tdsp_version(&ver))
  {
    ver.pos[0] = ver.pos[1] = ver.pos[2] = ver.pos[3] = 0;
  }
  char chversion[256] = { "" };
  char chtmp[256];
  /*in the follow function: 2=major_version, 0=minor_version,7=sub_minor_version */
  sprintf(chversion, "\t%s wb %d.%d.%d\n\n", m_chcompanyid, 2, 0, 7);
  if (ver.pos[0] == 1)
  {
    sprintf(chtmp, "bluetooth: \n-%s\n", (const char *) ver.btver);
  }
  else
  {
    sprintf(chtmp, "bluetooth: %s\n", "invalid");
  }
  strcat(chversion, chtmp);
  if (ver.pos[1] == 1)
  {
    sprintf(chtmp, "wlan: \n-%s\n", (const char *) ver.wlanver);
  }
  else
  {
    sprintf(chtmp, "wlan: %s\n", "invalid");
  }
  strcat(chversion, chtmp);
  if (ver.pos[2] == 1)
  {
    sprintf(chtmp, "%sbus: %s\n", m_chcompanyid, (const char *) ver.busver);
  }
  else
  {
    sprintf(chtmp, "bus driver: %s\n", "invalid");
  }
  strcat(chversion, chtmp);
  if (ver.pos[3] == 1 && (ver.pos[0] + ver.pos[1] > 0))
  {
    strcat(chversion, "firmware:");
    strcpy(chtmp, "");
    char chversiontmp[50] = { "" };
    sprintf(chversiontmp, "%08x", (unsigned int) ver.firmwarever);

    char chv[10];

    // board type
    char chboardtype[10] = "";
    chboardtype[0] = chversiontmp[0];
    chboardtype[1] = chversiontmp[1];
    chboardtype[2] = '\0';
    int board_type;
    hexstr2intnum(chboardtype, 2, &board_type);
    int major_version;
    chv[0] = chversiontmp[2];
    chv[1] = chversiontmp[3];
    chv[2] = '\0';
    hexstr2intnum(chv, 2, &major_version);
    char chtesttype[10] = "";
    chtesttype[0] = chversiontmp[4];
    chtesttype[1] = chversiontmp[5];
    chtesttype[2] = '\0';
    int test_type;
    hexstr2intnum(chtesttype, 2, &test_type);
    int minor_version;
    chv[0] = chversiontmp[6];
    chv[1] = chversiontmp[7];
    chv[2] = '\0';
    hexstr2intnum(chv, 2, &minor_version);
    // sprintf(chtmp,"%2s.%02d.%2s.%03d\n",chboardtype,major_version,chtesttype,minor_version);
    sprintf(chtmp, "%2d.%02d.%2d.%03d\n", board_type, major_version, test_type, minor_version);
  }
  else
  {
    sprintf(chtmp, "firmware: %s\n", "invalid");
  }
  strcat(chversion, chtmp);

  strcpy(g_chversionstring, chversion);
  debug("updater_version get g_chversionstring= \n%s\n", g_chversionstring);
  return;
}

void tdsp_refresh_version()
{
  GtkTextBuffer *buffer;
  debug("call the function: tdsp_refresh_version()\n");
  update_ver_string();

  buffer = gtk_text_view_get_buffer(GTK_TEXT_VIEW(tdsp_text_view));
  gtk_text_buffer_set_text(buffer, g_chversionstring, strlen(g_chversionstring));
}

static void open_uri(GtkWindow * parent, const char *uri)
{
  GtkWidget *dialog;
  GdkScreen *screen;
  GError *error = NULL;
  gchar *cmdline;

  THISFUNCBECALLED;
  screen = gtk_window_get_screen(parent);
  cmdline = g_strconcat("xdg-open ", uri, NULL);

  if (gdk_spawn_command_line_on_screen(screen, cmdline, &error) == FALSE)
  {
    dialog = gtk_message_dialog_new(parent, GTK_DIALOG_DESTROY_WITH_PARENT, GTK_MESSAGE_ERROR, GTK_BUTTONS_CLOSE, error->message);
    gtk_dialog_run(GTK_DIALOG(dialog));
    gtk_widget_destroy(dialog);
    g_error_free(error);
  }

  g_free(cmdline);
}

static void about_url_hook(GtkAboutDialog * dialog, const gchar * url, gpointer data)
{
  open_uri(GTK_WINDOW(dialog), url);
}

static void about_email_hook(GtkAboutDialog * dialog, const gchar * email, gpointer data)
{
  gchar *uri;

  uri = g_strconcat("mailto:", email, NULL);
  debug("%s\n", uri);
  open_uri(GTK_WINDOW(dialog), uri);
  g_free(uri);
}

void about_callback(GtkWidget * item, gpointer user_data)
{
  const gchar *authors[] = {
    "3DSP <ritow.qi@3dsp.com.cn>",
    NULL
  };
  const gchar *artists[] = {
    "3DSP <ritow.qi@3dsp.com.cn>",
    NULL,
  };
  gchar commenttexts[64];
  gchar titletexts[64];

  gtk_about_dialog_set_url_hook(about_url_hook, NULL, NULL);
  gtk_about_dialog_set_email_hook(about_email_hook, NULL, NULL);
//  snprintf(commenttexts,63,"WB%s for 3DSP card (pci) Linux",VERSION);
  snprintf(titletexts, 63, "3DSP %sU", m_chproductid);
  snprintf(commenttexts, 63, "Release %s.%s", m_chversion, m_chreleasedate);
  printf("current version is %s\n", TDSPUWBVERION);
//  snprintf(commenttexts, 63, "%s%s.%sforlinux", m_chproductid, m_chversion, m_chreleasedate);
//  gtk_show_about_dialog(NULL, "version", VERSION,
  gtk_show_about_dialog(NULL, "version", "",    //TDSPUWBVERION,
                        "program-name", titletexts, "copyright", "Copyright \xc2\xa9 2008-2009 3DSP", "comments", commenttexts,
                        // "authors", authors,
                        // "artists", artists,
                        "translator-credits", _("translator-credits"), "website", "http://www.3dsp.com/", "website-label", "http://www.3dsp.com", "logo-icon-name", "3dspusbWB", NULL);
}

static void popup_callback(GObject * widget, guint button, guint activate_time, gpointer user_data)
{
  if (TRUE == g_isclickinginprogress)
    return;

  GtkWidget *menu = user_data;

  adjust_menu_item_auto();

  gtk_menu_popup(GTK_MENU(menu), NULL, NULL, gtk_status_icon_position_menu, GTK_STATUS_ICON(widget), button, activate_time);
  g_ismenuclicked = TRUE;
  return;
}

static void activate_callback(GObject * widget, gpointer user_data)
{
  if (TRUE == g_isclickinginprogress)
    return;

  guint32 activate_time = gtk_get_current_event_time();
  GtkWidget *menu;

  if (query_blinking() == TRUE)
  {
//    debug("in blinking !\n");
    disable_blinking();
    return;
  }
//debug("Not in blinking !\n");
  menu = user_data;
  adjust_menu_item_auto();

  gtk_menu_popup(GTK_MENU(menu), NULL, NULL, gtk_status_icon_position_menu, GTK_STATUS_ICON(widget), 0, activate_time);
  g_ismenuclicked = TRUE;
  return;

}

gint watch_time_out_function(gpointer data)
{
  if (g_isclickinginprogress == TRUE)
  {
    debug("watch time out function return for isclicking_in_progress\n");
    g_print("----in progress call time out----\n");
    return 1;
  }
  debug("-watch time out function enter\n");

  gboolean menustate;
  gint iconindex;
  iconindex = ICON_GRAY;
  menustate = FALSE;
  int ret;
  ret = tdsp_query_device();
  if (ret == TDSP_SERIAL_NO_NOCARD)
  {
    debug("3DSP Card is not in\n");
//    show_notification(_("uWB Notice"),_("FAIL !\n3DSP Card is not in"), NULL, 3, NULL);
//    usleep(1000000);
//    on_exit1_activate(NULL, NULL);
//    return 0;
  }
  else
  {
    tdsp_query_power_state();
    switch (g_buspowerstate)
    {
    case PowerOn:
      menustate = TRUE;
      iconindex = ICON_GREEN;
      break;
    case PowerOff:
      iconindex = ICON_GRAY;
      break;
    case PowerOff2On:
      iconindex = ICON_RED;
      break;
    case PowerOn2Off:
      iconindex = ICON_RED;
      break;
    default:
      break;
    }
  }

  if (menustate == TRUE)
    enable_wb_menu();
  else
    gray_wb_menu();

 /**green 0, red 1, gray 2 **/
  if (g_iconindex != iconindex)
  {
    g_iconindex = iconindex;
    adjust_icon(g_iconindex);

    switch (iconindex)
    {
    case ICON_GREEN:
      show_notification(_("uWB Notice"), _("3DSP Card is inserted"), NULL, SWITCH_NOTIFY_TIME, NULL);
      break;
    case ICON_GRAY:
      show_notification(_("uWB Notice"), _("3DSP Card is pulled out"), NULL, SWITCH_NOTIFY_TIME, NULL);
      break;
    default:
      break;
    }
  }
  return 1;
}

/*if the timer function return 0, the timer is killed!
gint watch_time_out_function(gpointer data)
{
  if (g_isclickinginprogress == TRUE)
  {
    debug("watch time out function return for isclicking_in_progress\n");
    return 1;
  }
  debug("-watch time out function enter\n");
  int ret;
  ret = tdsp_query_device();
  if (ret == TDSP_SERIAL_NO_NOCARD)
  {
    debug("no card so exit\n");
	show_notification(_("uWB Notice"), _("FAIL !\n3DSP Card doesn't exist, Quit"), NULL, 3, NULL);
    usleep(1000000);
    on_exit1_activate(NULL, NULL);
    return 0;
  }

  gboolean menustate;
  gint iconindex;
  iconindex=2;
  menustate = FALSE;

  tdsp_query_power_state();
  switch (g_buspowerstate)
  {
  case PowerOn:
    menustate = TRUE;
    iconindex = 0;
    break;
  case PowerOff:
    iconindex = 2;
    break;
  case PowerOff2On:
    iconindex = 1;
    break;
  case PowerOn2Off:
    iconindex = 1;
    break;
  default:
    break;
  }

  if (menustate == TRUE)
      enable_wb_menu();
  else
      gray_wb_menu();

 // green 0, red 1, gray 2 
  if (g_iconindex != iconindex)
  {
    g_iconindex = iconindex;
    adjust_icon(g_iconindex);
  }
  return 1;
}
*/

gint main(gint argc, gchar * argv[])
{
  if (maincontrol())
  {
    return 0;
  }
  if (query_self_process_num(argv[0]) != 1)
  {
    g_print("A same process is running already!\n");
    return 0;
  }
/***^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^***/
#ifdef ENABLE_NLS
  bindtextdomain(GETTEXT_PACKAGE, PACKAGE_LOCALE_DIR);
  bind_textdomain_codeset(GETTEXT_PACKAGE, "UTF-8");
  textdomain(GETTEXT_PACKAGE);
#endif

  gtk_set_locale();
  gtk_init(&argc, &argv);

  add_pixmap_directory(PACKAGE_DATA_DIR "/" PACKAGE "/pixmaps");

  /*
   * The following code was added by Glade to create one of each component
   * (except popup menus), just so that you see something after building
   * the project. Delete any components that you don't want shown initially.
   */

  g_allowedmodes[0] = 0;
  g_allowedmodes[1] = 0;
  g_allowedmodes[2] = 0;
  g_defaultmode = 3;

  if (get_config_from_file() == FALSE)
    debug("get the config file of wb fail!\n");

/***^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^***/
  GtkStatusIcon *statusicon;
  GtkWidget *menu;
//  GError *error = NULL;

  statusicon = init_notification();
  menu = create_menu1();

  g_signal_connect(statusicon, "activate", G_CALLBACK(activate_callback), menu);
  g_signal_connect(statusicon, "popup-menu", G_CALLBACK(popup_callback), menu);

/***^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^***/

  initial_wb_defaultmode();
  maincontrol();
  if (set_hotkey_flag((unsigned long) m_nHotKeyFlag) != 0)
    debug("set the hotkey flag of uwb fail!\n");
  g_print("AntennaFlag = %d\n", m_nAntennaFlag);
  if (set_antenna_flag((unsigned long) m_nAntennaFlag) != 0)
    debug("set the antenna flag of uwb fail!\n");

  refresh_gui_and_timeout();

//  g_ismenuclicked = TRUE;

  tdsp_init_menu();

  adjust_menu_item_auto();
//  adjust_tooltip_text(BLUETOOTH_ENABLE_WLAN_ENABLE);

  gint watch_timer = gtk_timeout_add(2000, (GtkFunction) watch_time_out_function, NULL);

/***^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^***/
  gtk_main();
  gtk_widget_destroy(menu);
  cleanup_notification();

  return 0;
}
